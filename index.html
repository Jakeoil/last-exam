<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Humanity's Last Exam</title>
<script>
MathJax = {
  tex: {
    inlineMath: [['\\(', '\\)'], ['$', '$']],
    displayMath: [['\\[', '\\]'], ['$$', '$$']]
  },
  startup: { typeset: false }
};
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" async></script>
<style>
  :root {
    --bg: #0e0e10;
    --surface: #1a1a2e;
    --surface2: #22223a;
    --border: #2e2e4a;
    --text: #e0e0e8;
    --text-dim: #8888a0;
    --accent: #7c6ff7;
    --accent-glow: rgba(124, 111, 247, 0.25);
    --green: #34d399;
    --red: #f87171;
    --orange: #fbbf24;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    background: var(--bg);
    color: var(--text);
    min-height: 100vh;
  }

  header {
    position: sticky;
    top: 0;
    z-index: 100;
    background: rgba(14, 14, 16, 0.85);
    backdrop-filter: blur(12px);
    border-bottom: 1px solid var(--border);
    padding: 12px 24px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 16px;
    flex-wrap: wrap;
  }

  .header-left {
    display: flex;
    align-items: center;
    gap: 16px;
    flex-shrink: 0;
  }

  .header-left h1 {
    font-size: 18px;
    font-weight: 700;
    letter-spacing: -0.5px;
    white-space: nowrap;
  }

  .header-left h1 span { color: var(--accent); }

  .score-display {
    display: flex;
    gap: 12px;
    font-size: 13px;
    font-weight: 600;
  }

  .score-correct { color: var(--green); }
  .score-wrong { color: var(--red); }
  .score-total { color: var(--text-dim); }

  .header-controls {
    display: flex;
    align-items: center;
    gap: 10px;
    flex-wrap: wrap;
  }

  select, .search-input {
    background: var(--surface);
    color: var(--text);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 6px 10px;
    font-size: 13px;
    outline: none;
  }

  select:focus, .search-input:focus {
    border-color: var(--accent);
    box-shadow: 0 0 0 2px var(--accent-glow);
  }

  .search-input { width: 180px; }

  .nav-row {
    display: flex;
    align-items: center;
    gap: 6px;
  }

  .nav-btn {
    background: var(--surface);
    color: var(--text);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 6px 12px;
    font-size: 13px;
    cursor: pointer;
    transition: all 0.15s;
  }

  .nav-btn:hover { border-color: var(--accent); background: var(--surface2); }
  .nav-btn:disabled { opacity: 0.3; cursor: default; }

  .question-counter {
    font-size: 13px;
    color: var(--text-dim);
    min-width: 80px;
    text-align: center;
    display: flex;
    align-items: center;
    gap: 2px;
  }

  .question-num-input {
    width: 42px;
    background: var(--surface2);
    color: var(--text);
    border: 1px dashed var(--border);
    border-radius: 4px;
    padding: 2px 4px;
    font-size: 13px;
    text-align: center;
    outline: none;
    cursor: text;
    -moz-appearance: textfield;
  }

  .question-num-input::-webkit-outer-spin-button,
  .question-num-input::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }

  .question-num-input:hover {
    border-color: var(--accent);
  }

  .question-num-input:focus {
    border-style: solid;
    border-color: var(--accent);
    box-shadow: 0 0 0 2px var(--accent-glow);
  }

  .shuffle-btn {
    background: var(--surface);
    color: var(--orange);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 6px 10px;
    font-size: 13px;
    cursor: pointer;
    transition: all 0.15s;
  }

  .shuffle-btn:hover { border-color: var(--orange); }

  .clear-btn {
    background: var(--surface);
    color: var(--red);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 6px 10px;
    font-size: 13px;
    cursor: pointer;
    transition: all 0.15s;
  }

  .clear-btn:hover { border-color: var(--red); }

  main {
    max-width: 860px;
    margin: 0 auto;
    padding: 32px 24px 80px;
  }

  .question-card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 12px;
    overflow: hidden;
  }

  .card-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 16px 20px;
    border-bottom: 1px solid var(--border);
    flex-wrap: wrap;
    gap: 8px;
  }

  .badge {
    display: inline-block;
    padding: 3px 10px;
    border-radius: 20px;
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .badge-category {
    background: rgba(124, 111, 247, 0.15);
    color: var(--accent);
  }

  .badge-subject {
    background: rgba(52, 211, 153, 0.12);
    color: var(--green);
  }

  .badge-type {
    background: rgba(251, 191, 36, 0.12);
    color: var(--orange);
  }

  .card-body { padding: 24px 20px; }

  .question-text code {
    font-family: 'SFMono-Regular', 'Consolas', 'Liberation Mono', 'Menlo', monospace;
    font-size: 0.9em;
    background: var(--surface2);
    padding: 1px 5px;
    border-radius: 3px;
    border: 1px solid var(--border);
  }

  .question-text pre {
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 12px 16px;
    overflow-x: auto;
    margin: 8px 0;
  }

  .question-text pre code {
    background: none;
    border: none;
    padding: 0;
    font-size: 13px;
    line-height: 1.5;
  }

  .question-text {
    font-size: 16px;
    line-height: 1.7;
    white-space: pre-wrap;
    word-wrap: break-word;
  }

  .question-image {
    margin-top: 20px;
    text-align: center;
  }

  .question-image img {
    max-width: 100%;
    max-height: 600px;
    border-radius: 8px;
    border: 1px solid var(--border);
  }

  .answer-section {
    padding: 20px;
    border-top: 1px solid var(--border);
  }

  .mc-options {
    display: flex;
    flex-direction: column;
    gap: 8px;
    margin-bottom: 16px;
  }

  .mc-option {
    display: flex;
    align-items: flex-start;
    gap: 10px;
    padding: 10px 14px;
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.15s;
    font-size: 14px;
    line-height: 1.5;
  }

  .mc-option:hover { border-color: var(--accent); }

  .mc-option.selected {
    border-color: var(--accent);
    background: var(--accent-glow);
  }

  .mc-option.correct {
    border-color: var(--green);
    background: rgba(52, 211, 153, 0.1);
  }

  .mc-option.wrong {
    border-color: var(--red);
    background: rgba(248, 113, 113, 0.1);
  }

  .mc-option input[type="radio"] { display: none; }

  .mc-letter {
    flex-shrink: 0;
    width: 24px;
    height: 24px;
    border-radius: 50%;
    background: var(--border);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    font-weight: 700;
  }

  .selected .mc-letter { background: var(--accent); color: #fff; }
  .correct .mc-letter { background: var(--green); color: #fff; }
  .wrong .mc-letter { background: var(--red); color: #fff; }

  .exact-input {
    width: 100%;
    padding: 10px 14px;
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 8px;
    color: var(--text);
    font-size: 14px;
    outline: none;
    margin-bottom: 16px;
  }

  .exact-input:focus {
    border-color: var(--accent);
    box-shadow: 0 0 0 2px var(--accent-glow);
  }

  .btn-row {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
  }

  .submit-btn {
    background: var(--accent);
    color: #fff;
    border: none;
    border-radius: 8px;
    padding: 10px 24px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: opacity 0.15s;
  }

  .submit-btn:hover { opacity: 0.85; }
  .submit-btn:disabled { opacity: 0.4; cursor: default; }

  .reveal-btn {
    background: transparent;
    color: var(--text-dim);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 10px 20px;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.15s;
  }

  .reveal-btn:hover { border-color: var(--text-dim); color: var(--text); }

  .result-banner {
    margin-top: 16px;
    padding: 12px 16px;
    border-radius: 8px;
    font-size: 14px;
    font-weight: 600;
    display: none;
  }

  .result-banner.correct {
    display: block;
    background: rgba(52, 211, 153, 0.1);
    border: 1px solid var(--green);
    color: var(--green);
  }

  .result-banner.wrong {
    display: block;
    background: rgba(248, 113, 113, 0.1);
    border: 1px solid var(--red);
    color: var(--red);
  }

  .rationale-section {
    margin-top: 16px;
    padding: 16px;
    background: var(--surface2);
    border-radius: 8px;
    border: 1px solid var(--border);
    display: none;
  }

  .rationale-section.visible { display: block; }

  .rationale-section h4 {
    font-size: 12px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: var(--text-dim);
    margin-bottom: 8px;
  }

  .rationale-section p {
    font-size: 14px;
    line-height: 1.6;
    white-space: pre-wrap;
    word-wrap: break-word;
  }

  .answer-display {
    margin-top: 8px;
    font-size: 14px;
    color: var(--green);
  }

  .keyboard-hint {
    position: fixed;
    bottom: 16px;
    right: 16px;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 8px 14px;
    font-size: 11px;
    color: var(--text-dim);
    display: flex;
    gap: 12px;
  }

  kbd {
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 3px;
    padding: 1px 5px;
    font-family: inherit;
    font-size: 11px;
  }

  .fen-board {
    display: inline-grid;
    grid-template-columns: repeat(8, 1fr);
    border: 2px solid var(--border);
    border-radius: 4px;
    overflow: hidden;
    width: 240px;
    height: 240px;
    vertical-align: middle;
    margin: 8px 4px;
  }

  .fen-board .sq {
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
    line-height: 1;
    aspect-ratio: 1;
  }

  .fen-board .sq .pc {
    font-family: 'DejaVu Sans', 'Segoe UI Symbol', sans-serif;
    font-style: normal;
  }

  .fen-board .sq .pc.w {
    color: #fff;
    text-shadow:
      -1px 0 1px rgba(0,0,0,0.6),
       1px 0 1px rgba(0,0,0,0.6),
       0 -1px 1px rgba(0,0,0,0.6),
       0  1px 1px rgba(0,0,0,0.6);
  }

  .fen-board .sq .pc.b {
    color: #1a1a1a;
    text-shadow:
      -1px 0 1px rgba(255,255,255,0.3),
       1px 0 1px rgba(255,255,255,0.3),
       0 -1px 1px rgba(255,255,255,0.3),
       0  1px 1px rgba(255,255,255,0.3);
  }

  .fen-board .sq.light { background: #e8d5a8; }
  .fen-board .sq.dark { background: #b58863; }

  .fen-label {
    font-size: 11px;
    color: var(--text-dim);
    text-align: center;
    margin-bottom: 2px;
  }

  .fen-container {
    display: inline-block;
    margin: 8px 8px 8px 0;
    vertical-align: top;
  }

  .drop-zone {
    border: 2px dashed var(--border);
    border-radius: 12px;
    padding: 60px 20px;
    text-align: center;
    cursor: pointer;
    transition: all 0.2s;
  }

  .drop-zone:hover, .drop-zone.drag-over {
    border-color: var(--accent);
    background: var(--accent-glow);
  }

  .drop-zone h2 {
    font-size: 20px;
    margin-bottom: 12px;
    color: var(--text);
  }

  .drop-zone p {
    font-size: 14px;
    color: var(--text-dim);
    line-height: 1.6;
  }

  .drop-zone .accent { color: var(--accent); }

  .drop-zone .progress {
    margin-top: 16px;
    font-size: 13px;
    color: var(--accent);
  }

  @media (max-width: 640px) {
    header { padding: 10px 12px; }
    main { padding: 16px 12px 80px; }
    .card-body { padding: 16px 14px; }
    .answer-section { padding: 14px; }
    .search-input { width: 120px; }
    .keyboard-hint { display: none; }
  }
</style>
</head>
<body>

<header>
  <div class="header-left">
    <h1><span>HLE</span> Humanity's Last Exam</h1>
    <div class="score-display">
      <span class="score-correct" id="scoreCorrect">0 correct</span>
      <span class="score-wrong" id="scoreWrong">0 wrong</span>
      <span class="score-total" id="scoreTotal">/ 0 answered</span>
    </div>
  </div>
  <div class="header-controls">
    <select id="categoryFilter"><option value="">All Categories</option></select>
    <select id="typeFilter">
      <option value="">All Types</option>
      <option value="multipleChoice">Multiple Choice</option>
      <option value="exactMatch">Exact Match</option>
    </select>
    <input type="text" class="search-input" id="searchInput" placeholder="Search questions...">
    <button class="shuffle-btn" id="shuffleBtn" title="Shuffle">Shuffle</button>
    <button class="clear-btn" id="clearBtn" title="Clear cached data and reset">Clear data</button>
    <div class="nav-row">
      <button class="nav-btn" id="prevBtn">&larr; Prev</button>
      <span class="question-counter" id="questionCounter"><input type="number" class="question-num-input" id="questionNumInput" value="1" min="1"> / <span id="questionTotal">2500</span></span>
      <button class="nav-btn" id="nextBtn">Next &rarr;</button>
    </div>
  </div>
</header>

<main>
  <div class="question-card" id="questionCard"></div>
</main>

<div class="keyboard-hint">
  <span><kbd>&larr;</kbd> Prev</span>
  <span><kbd>&rarr;</kbd> Next</span>
  <span><kbd>Enter</kbd> Submit</span>
  <span><kbd>R</kbd> Reveal</span>
</div>

<script>
let allQuestions = [];
let filtered = [];
let currentIdx = 0;
let scores = JSON.parse(localStorage.getItem('hle_scores') || '{"correct":0,"wrong":0}');
let answered = JSON.parse(localStorage.getItem('hle_answered') || '{}');

function saveState() {
  localStorage.setItem('hle_scores', JSON.stringify(scores));
  localStorage.setItem('hle_answered', JSON.stringify(answered));
}

const DB_NAME = 'hle_cache';
const DB_STORE = 'questions';

function openDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => req.result.createObjectStore(DB_STORE);
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

async function getCachedQuestions() {
  try {
    const db = await openDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(DB_STORE, 'readonly');
      const req = tx.objectStore(DB_STORE).get('data');
      req.onsuccess = () => resolve(req.result || null);
      req.onerror = () => reject(req.error);
    });
  } catch { return null; }
}

async function cacheQuestions(data) {
  try {
    const db = await openDB();
    const tx = db.transaction(DB_STORE, 'readwrite');
    tx.objectStore(DB_STORE).put(data, 'data');
  } catch {}
}

function showDropZone() {
  const card = document.getElementById('questionCard');
  card.innerHTML = `
    <div class="drop-zone" id="dropZone">
      <h2>Drop your <span class="accent">.parquet</span> file here</h2>
      <p><a href="https://huggingface.co/join" target="_blank" style="color:var(--accent);">Join</a> and log in to HuggingFace, then download your local copy of
        <span class="accent">test-00000-of-00001.parquet</span> from the
        <a href="https://huggingface.co/datasets/cais/hle/tree/main/data" target="_blank" style="color:var(--accent);">data folder</a>
        and drop it here.</p>
      <p style="margin-top:8px;font-size:13px;">On HuggingFace: go to <b>Files and versions</b> &rarr; <b>data/</b> folder &rarr; click the download icon next to the .parquet file.</p>
      <p style="margin-top:8px;">The file is decoded locally in your browser. Nothing is uploaded.</p>
      <div class="progress" id="dropProgress"></div>
    </div>
  `;
  const zone = document.getElementById('dropZone');
  zone.addEventListener('dragover', e => { e.preventDefault(); zone.classList.add('drag-over'); });
  zone.addEventListener('dragleave', () => zone.classList.remove('drag-over'));
  zone.addEventListener('drop', async e => {
    e.preventDefault();
    zone.classList.remove('drag-over');
    const file = e.dataTransfer.files[0];
    if (!file) return;
    await handleParquetFile(file);
  });
  zone.addEventListener('click', () => {
    const inp = document.createElement('input');
    inp.type = 'file';
    inp.accept = '.parquet';
    inp.onchange = async () => { if (inp.files[0]) await handleParquetFile(inp.files[0]); };
    inp.click();
  });
}

async function handleParquetFile(file) {
  const progress = document.getElementById('dropProgress');
  progress.textContent = 'Reading file...';
  try {
    const buffer = await file.arrayBuffer();
    progress.textContent = 'Decoding parquet (this may take a moment)...';
    await new Promise(r => setTimeout(r, 50));
    const { parquetRead } = await import('https://esm.run/hyparquet@1');
    const rows = [];
    await parquetRead({
      file: buffer,
      columns: ['id', 'question', 'image', 'answer', 'answer_type', 'author_name', 'rationale', 'raw_subject', 'category'],
      onComplete: data => {
        for (const row of data) {
          rows.push({
            id: row[0],
            question: row[1],
            image: row[2] || null,
            answer: row[3],
            answer_type: row[4],
            author: row[5] || null,
            rationale: row[6] || null,
            subject: row[7] || null,
            category: row[8] || null,
          });
        }
      }
    });
    progress.textContent = `Loaded ${rows.length} questions. Caching...`;
    allQuestions = rows;
    await cacheQuestions(rows);
    startQuiz();
  } catch (err) {
    progress.textContent = 'Error: ' + err.message;
    progress.style.color = 'var(--red)';
  }
}

function startQuiz() {
  populateFilters();
  applyFilters();
  const saved = parseInt(localStorage.getItem('hle_currentIdx'), 10);
  if (!isNaN(saved) && saved < filtered.length) currentIdx = saved;
  updateScores();
  render();
  bindEvents();
}

async function init() {
  // Try fetching questions.json first (local dev with HTTP server)
  try {
    const resp = await fetch('questions.json');
    if (!resp.ok) throw new Error(resp.status);
    allQuestions = await resp.json();
    startQuiz();
    return;
  } catch {}

  // Try IndexedDB cache (returning visitor on GitHub Pages)
  const cached = await getCachedQuestions();
  if (cached) {
    allQuestions = cached;
    startQuiz();
    return;
  }

  // Show drop zone
  showDropZone();
}

function populateFilters() {
  const cats = [...new Set(allQuestions.map(q => q.category).filter(Boolean))].sort();
  const sel = document.getElementById('categoryFilter');
  cats.forEach(c => {
    const opt = document.createElement('option');
    opt.value = c;
    opt.textContent = c;
    sel.appendChild(opt);
  });
}

function applyFilters() {
  const cat = document.getElementById('categoryFilter').value;
  const type = document.getElementById('typeFilter').value;
  const search = document.getElementById('searchInput').value.toLowerCase().trim();

  filtered = allQuestions.filter(q => {
    if (cat && q.category !== cat) return false;
    if (type && q.answer_type !== type) return false;
    if (search && !q.question.toLowerCase().includes(search) &&
        !(q.subject || '').toLowerCase().includes(search)) return false;
    return true;
  });

  if (currentIdx >= filtered.length) currentIdx = 0;
  updateCounter();
}

function updateCounter() {
  const numInput = document.getElementById('questionNumInput');
  numInput.value = filtered.length ? currentIdx + 1 : 0;
  numInput.max = filtered.length;
  document.getElementById('questionTotal').textContent = filtered.length;
  document.getElementById('prevBtn').disabled = currentIdx <= 0;
  document.getElementById('nextBtn').disabled = currentIdx >= filtered.length - 1;
  localStorage.setItem('hle_currentIdx', currentIdx);
}

function updateScores() {
  document.getElementById('scoreCorrect').textContent = `${scores.correct} correct`;
  document.getElementById('scoreWrong').textContent = `${scores.wrong} wrong`;
  document.getElementById('scoreTotal').textContent = `/ ${scores.correct + scores.wrong} answered`;
}

function render() {
  const card = document.getElementById('questionCard');
  if (!filtered.length) {
    card.innerHTML = '<div class="card-body" style="text-align:center;color:var(--text-dim);padding:60px 20px;">No questions match your filters.</div>';
    updateCounter();
    return;
  }

  const q = filtered[currentIdx];
  const prev = answered[q.id];
  const isRevealed = prev && prev.revealed;
  const isAnswered = prev && prev.submitted;

  let answerHTML = '';
  if (q.answer_type === 'multipleChoice') {
    const choices = parseChoices(q.question);
    answerHTML = `<div class="mc-options" id="mcOptions">` +
      choices.map(c => {
        let cls = 'mc-option';
        if (isAnswered) {
          if (c.letter === q.answer) cls += ' correct';
          else if (prev && c.letter === prev.userAnswer) cls += ' wrong';
        } else if (prev && c.letter === prev.userAnswer) {
          cls += ' selected';
        }
        return `<label class="${cls}" data-letter="${c.letter}">
          <span class="mc-letter">${c.letter}</span>
          <span>${renderCode(escapeHTML(wrapBareLaTeX(c.text)))}</span>
        </label>`;
      }).join('') + `</div>`;
  } else {
    const val = (prev && prev.userAnswer) || '';
    answerHTML = `<input type="text" class="exact-input" id="exactInput"
      placeholder="Type your answer..." value="${escapeHTML(val)}"
      ${isAnswered ? 'disabled' : ''}>`;
  }

  let resultHTML = '';
  if (isAnswered) {
    resultHTML = prev.correct
      ? `<div class="result-banner correct">Correct!</div>`
      : `<div class="result-banner wrong">Incorrect. The answer is: ${escapeHTML(wrapBareLaTeX(q.answer))}</div>`;
  }

  let rationaleHTML = '';
  if ((isAnswered || isRevealed) && q.rationale) {
    rationaleHTML = `<div class="rationale-section visible">
      <h4>Rationale</h4>
      <p>${renderCode(escapeHTML(wrapBareLaTeX(q.rationale)))}</p>
    </div>`;
  }

  if (isRevealed && !isAnswered) {
    resultHTML = `<div class="result-banner correct" style="color:var(--orange);border-color:var(--orange);background:rgba(251,191,36,0.08);">
      Answer: ${escapeHTML(wrapBareLaTeX(q.answer))}</div>`;
  }

  const questionBody = q.answer_type === 'multipleChoice'
    ? stripChoicesFromQuestion(q.question) : q.question;

  card.innerHTML = `
    <div class="card-header">
      <div style="display:flex;gap:6px;flex-wrap:wrap;">
        ${q.category ? `<span class="badge badge-category">${escapeHTML(q.category)}</span>` : ''}
        ${q.subject ? `<span class="badge badge-subject">${escapeHTML(q.subject)}</span>` : ''}
        <span class="badge badge-type">${q.answer_type === 'multipleChoice' ? 'Multiple Choice' : 'Exact Match'}</span>
      </div>
      ${q.author ? `<span style="font-size:12px;color:var(--text-dim);">by ${escapeHTML(q.author)}</span>` : ''}
    </div>
    <div class="card-body">
      <div class="question-text">${renderCode(renderFEN(escapeHTML(wrapBareLaTeX(questionBody))))}</div>
      ${q.image ? `<div class="question-image"><img src="${q.image}" alt="Question image" loading="lazy"></div>` : ''}
    </div>
    <div class="answer-section">
      ${answerHTML}
      <div class="btn-row">
        <button class="submit-btn" id="submitBtn" ${isAnswered ? 'disabled' : ''}>Submit</button>
        <button class="reveal-btn" id="revealBtn" ${isAnswered || isRevealed ? 'disabled' : ''}>Reveal Answer</button>
      </div>
      ${resultHTML}
      ${rationaleHTML}
    </div>
  `;

  // Bind MC click handlers
  if (q.answer_type === 'multipleChoice' && !isAnswered) {
    card.querySelectorAll('.mc-option').forEach(opt => {
      opt.addEventListener('click', () => {
        card.querySelectorAll('.mc-option').forEach(o => o.classList.remove('selected'));
        opt.classList.add('selected');
        if (!answered[q.id]) answered[q.id] = {};
        answered[q.id].userAnswer = opt.dataset.letter;
      });
    });
  }

  if (q.answer_type === 'exactMatch' && !isAnswered) {
    const inp = document.getElementById('exactInput');
    inp.addEventListener('input', () => {
      if (!answered[q.id]) answered[q.id] = {};
      answered[q.id].userAnswer = inp.value;
    });
  }

  document.getElementById('submitBtn').addEventListener('click', submit);
  document.getElementById('revealBtn').addEventListener('click', reveal);
  updateCounter();
  if (window.MathJax && MathJax.typesetPromise) {
    MathJax.typesetPromise([card]).catch(() => {});
  }
}

function submit() {
  const q = filtered[currentIdx];
  if (!q) return;
  const prev = answered[q.id];
  if (prev && prev.submitted) return;

  const userAnswer = prev ? prev.userAnswer : '';
  if (!userAnswer) return;

  let correct = false;
  if (q.answer_type === 'multipleChoice') {
    correct = userAnswer === q.answer;
  } else {
    correct = userAnswer.trim().toLowerCase() === q.answer.trim().toLowerCase();
  }

  answered[q.id] = { userAnswer, correct, submitted: true };
  if (correct) scores.correct++;
  else scores.wrong++;
  saveState();
  updateScores();
  render();
}

function reveal() {
  const q = filtered[currentIdx];
  if (!q) return;
  if (!answered[q.id]) answered[q.id] = {};
  answered[q.id].revealed = true;
  saveState();
  render();
}

function parseChoices(text) {
  // Extract the answer choices section
  const choicesIdx = text.indexOf('Answer Choices:');
  if (choicesIdx === -1) return [];
  const choicesText = text.slice(choicesIdx);

  // Split on choice letters at the start of a line, capturing multi-line content
  const choices = [];
  const parts = choicesText.split(/^([A-Z])[.)]\s/m);
  // parts: ["Answer Choices:\n", "A", "content...", "B", "content...", ...]
  for (let i = 1; i < parts.length; i += 2) {
    choices.push({ letter: parts[i], text: parts[i + 1].trim() });
  }
  return choices;
}

function stripChoicesFromQuestion(text) {
  const choicesIdx = text.indexOf('Answer Choices:');
  if (choicesIdx === -1) return text;
  return text.slice(0, choicesIdx).trim();
}

function escapeHTML(s) {
  if (!s) return '';
  return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
}

// Wrap bare LaTeX (not already inside \(\), \[\], or $$) in \( \) delimiters.
// Matches: \command sequences, subscript/superscript chains, and runs of
// adjacent math tokens like "A_i^\dagger A_j".
function wrapBareLaTeX(s) {
  if (!s) return s;
  // Split text into already-delimited math regions, code blocks, and plain text.
  // Preserve \(...\), \[...\], $...$, and ```...``` as-is.
  const parts = [];
  const mathDelim = /(```[\s\S]*?```|`[^`]+`|\\\([\s\S]*?\\\)|\\\[[\s\S]*?\\\]|\$\$[\s\S]*?\$\$|\$[^$]+?\$)/g;
  let last = 0;
  let m;
  while ((m = mathDelim.exec(s)) !== null) {
    if (m.index > last) parts.push({ text: s.slice(last, m.index), isMath: false });
    parts.push({ text: m[0], isMath: true });
    last = m.index + m[0].length;
  }
  if (last < s.length) parts.push({ text: s.slice(last), isMath: false });

  // In plain text regions, find bare LaTeX tokens and wrap them.
  // A token is: optional word chars, then subscript/superscript and/or backslash-command,
  // possibly chained (e.g. "A_i^\dagger" or "A_{ab}" or "\neq" or "tr(A_i^\dagger A_j)")
  const latexToken = /(?:[A-Za-z0-9]+(?:[_^](?:\{[^}]*\}|[A-Za-z0-9]))+(?:\\[a-zA-Z]+)*|\\(?:neq|dagger|infty|frac|sqrt|sum|prod|int|alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|pi|rho|sigma|tau|phi|chi|psi|omega|cdot|ldots|cdots|times|leq|geq|subset|supset|subseteq|supseteq|cap|cup|wedge|vee|forall|exists|partial|nabla|ell|hbar|otimes|oplus|langle|rangle|mathbb|mathrm|mathcal|mathbf|operatorname|text|binom|choose|log|ln|exp|sin|cos|tan|det|dim|ker|mod|gcd|min|max|lim|sup|inf)(?:\{[^}]*\})*(?:[_^](?:\{[^}]*\}|[A-Za-z0-9]))*)/g;

  return parts.map(p => {
    if (p.isMath) return p.text;
    // For each bare LaTeX match, wrap in \( \)
    return p.text.replace(latexToken, (match) => '\\(' + match + '\\)');
  }).join('');
}

// Use filled glyphs (U+265A-265F) for all pieces; distinguish by CSS color class.
const FEN_PIECES = {
  'K': '♚', 'Q': '♛', 'R': '♜', 'B': '♝', 'N': '♞', 'P': '♟',
  'k': '♚', 'q': '♛', 'r': '♜', 'b': '♝', 'n': '♞', 'p': '♟'
};

function fenToBoard(fen) {
  const placement = fen.split(' ')[0];
  const rows = placement.split('/');
  let html = '';
  for (let r = 0; r < 8; r++) {
    let col = 0;
    for (const ch of rows[r]) {
      if (ch >= '1' && ch <= '8') {
        for (let n = 0; n < parseInt(ch); n++) {
          const shade = (r + col) % 2 === 0 ? 'light' : 'dark';
          html += `<div class="sq ${shade}"></div>`;
          col++;
        }
      } else {
        const shade = (r + col) % 2 === 0 ? 'light' : 'dark';
        const side = ch >= 'A' && ch <= 'Z' ? 'w' : 'b';
        html += `<div class="sq ${shade}"><span class="pc ${side}">${FEN_PIECES[ch] || ''}</span></div>`;
        col++;
      }
    }
  }
  return html;
}

// Detect FEN strings in text and replace with rendered boards.
// FEN pattern: 8 ranks separated by /, followed by side/castling/en-passant/clocks
function renderFEN(s) {
  const fenRegex = /([rnbqkpRNBQKP1-8]{1,8}\/){7}[rnbqkpRNBQKP1-8]{1,8}\s+[wb]\s+[KQkq-]{1,4}\s+[a-h1-8-]{1,2}\s+\d+\s+\d+/g;
  return s.replace(fenRegex, (match) => {
    const label = match.trim();
    const board = fenToBoard(match.trim());
    return `</span><div class="fen-container"><div class="fen-label">${label}</div><div class="fen-board">${board}</div></div><span>`;
  });
}

function renderCode(s) {
  // Fenced code blocks: ```...```
  s = s.replace(/```(?:\w*)\n?([\s\S]*?)```/g, '<pre><code>$1</code></pre>');
  // Inline code: `...`
  s = s.replace(/`([^`]+)`/g, '<code>$1</code>');
  return s;
}

function bindEvents() {
  document.getElementById('prevBtn').addEventListener('click', () => { if (currentIdx > 0) { currentIdx--; render(); } });
  document.getElementById('nextBtn').addEventListener('click', () => { if (currentIdx < filtered.length - 1) { currentIdx++; render(); } });
  document.getElementById('categoryFilter').addEventListener('change', () => { applyFilters(); render(); });
  document.getElementById('typeFilter').addEventListener('change', () => { applyFilters(); render(); });

  const numInput = document.getElementById('questionNumInput');
  function jumpToNum() {
    if (!filtered.length) return;
    let val = parseInt(numInput.value, 10);
    if (isNaN(val) || val < 1) val = 1;
    if (val > filtered.length) val = filtered.length;
    currentIdx = val - 1;
    render();
  }
  numInput.addEventListener('change', jumpToNum);
  numInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') { e.preventDefault(); jumpToNum(); numInput.blur(); }
  });
  numInput.addEventListener('focus', () => numInput.select());

  let searchTimeout;
  document.getElementById('searchInput').addEventListener('input', () => {
    clearTimeout(searchTimeout);
    searchTimeout = setTimeout(() => { applyFilters(); render(); }, 300);
  });

  document.getElementById('clearBtn').addEventListener('click', async () => {
    if (!confirm('Clear all cached data, scores, and answers?')) return;
    try {
      const db = await openDB();
      const tx = db.transaction(DB_STORE, 'readwrite');
      tx.objectStore(DB_STORE).clear();
    } catch {}
    localStorage.removeItem('hle_scores');
    localStorage.removeItem('hle_answered');
    localStorage.removeItem('hle_currentIdx');
    location.reload();
  });

  document.getElementById('shuffleBtn').addEventListener('click', () => {
    for (let i = filtered.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [filtered[i], filtered[j]] = [filtered[j], filtered[i]];
    }
    currentIdx = 0;
    render();
  });

  document.addEventListener('keydown', e => {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
      if (e.key === 'Enter' && e.target.id !== 'searchInput' && e.target.id !== 'questionNumInput') {
        e.preventDefault(); submit();
      }
      return;
    }
    if (e.key === 'ArrowLeft') { if (currentIdx > 0) { currentIdx--; render(); } }
    else if (e.key === 'ArrowRight') { if (currentIdx < filtered.length - 1) { currentIdx++; render(); } }
    else if (e.key === 'Enter') submit();
    else if (e.key === 'r' || e.key === 'R') reveal();
    else if (q_answer_type_is_mc() && /^[a-eA-E]$/.test(e.key)) {
      const letter = e.key.toUpperCase();
      const opt = document.querySelector(`.mc-option[data-letter="${letter}"]`);
      if (opt) opt.click();
    }
  });
}

function q_answer_type_is_mc() {
  if (!filtered.length) return false;
  return filtered[currentIdx].answer_type === 'multipleChoice';
}

init();
</script>

</body>
</html>
